# **面试题15. 二进制中1的个数**

* 在算数运算中除2尽量用位移运算，比除法运算要高效率的多；

## **Link**

<<https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/submissions>

## 题目描述

$^1$ 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

### 示例 1

```bash
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

### 示例 2

```bash
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

### 示例 3

```bash
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

## **题目分析**

* 从左往右位移 (O(n), O(1))
  * 新建一个uint32_t类型mask 值为1；
  * 输入的值n，与mask做与运算，看值是否为1，是则代表n的最后一位目前为1，否则最后一位目前为0；
  * n每执行完一次与运算，就向右位移，直到n为0为止；
  > 但是该算法有个致命弱点，如果开头sign bit为1（输入为负数），则该算法会无限循环（负数右位移开头不断补1）；

* 从右往左位移遍历 (O(n), O(1))
  * 新建uint32_t类型mask 值为1；
  * 输入的值n，与mask做与运算，看得到的值是否为1，是则count加1；
  * mask每执行完一次与运算，则向左位移，直到mask为最大为止；
  
* 简便的减法与位与算法
  * $n = (n - 1) \ and \ n$ 可以去掉最右边的1，直到n为0为止;
    * e.g
      $$
      n = 12 = 0b1100
      $$
      $$
      x = n - 1 = 0b1011
      $$

      $$
      n = x \ and \ n = 0b1000 \ | \ then \ count++
      $$

## **题解**

>C++ 遍历

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        if (n == 0) return 0;

        uint32_t mask = 1;
        int cnt = 0, shift = 0;
        while (mask <= n && shift < 32) {
            if ( (mask & n) != 0 ) {
                cnt += 1;
            }
            mask = mask << 1;
            shift++;
        }

        return cnt;
    }
};
```

>C++ 把最右的1减去

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int cnt = 0;
        while (n > 0) {
            ++cnt;
            n = (n - 1) & n;
        }

        return cnt;
    }
};
```

## **reference**

$^1$ 来源：力扣（LeetCode）
链接：<https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
